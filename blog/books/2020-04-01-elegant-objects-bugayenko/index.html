<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Мнение о книге "Elegant Objects" (Vol.1) Е.Бугаенко | Maxim Gorbatyuk blog</title><meta name=keywords content="codestyle,advices,programming,yegor256"><meta name=description content="О книге Книга &ldquo;Элегантные объекты. Java Edition&rdquo; не сильно распространена на рынке в Казахстане, где я живу. Как только узнал, что появилась возможность приобрести в магазине flip.kz - купил тут же.
В предисловии автор рассказывает историю создания языков через его призму восприятия. Он пишет, что 20 лет назад языки программирования были процедурные, не было классов и ООП. И именно эти программисты, которые мыслили процедурно, и создали первые ООП-языки. Егор нисколько не умаляет их заслуг, но говорит о том, что подход к ООП с тех пор практически не изменился и программисты сейчас пишут на Java/."><meta name=author content="Maxim"><link rel=canonical href=https://maximgorbatyuk.github.io/blog/books/2020-04-01-elegant-objects-bugayenko/><link href=/assets/css/stylesheet.min.445d5432f5ab73238331899e4bf224a7bca046e4af100cb31e71c7af0453cb13.css integrity="sha256-RF1UMvWrcyODMYmeS/Ikp7ygRuSvEAyzHnHHrwRTyxM=" rel="preload stylesheet" as=style><link rel=icon href=https://maximgorbatyuk.github.io/images/avatar.png><link rel=icon type=image/png sizes=16x16 href=https://maximgorbatyuk.github.io/images/avatar.png><link rel=icon type=image/png sizes=32x32 href=https://maximgorbatyuk.github.io/images/avatar.png><link rel=apple-touch-icon href=https://maximgorbatyuk.github.io/images/avatar.png><link rel=mask-icon href=https://maximgorbatyuk.github.io/images/avatar.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-86410344-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Мнение о книге &#34;Elegant Objects&#34; (Vol.1) Е.Бугаенко"><meta property="og:description" content="О книге Книга &ldquo;Элегантные объекты. Java Edition&rdquo; не сильно распространена на рынке в Казахстане, где я живу. Как только узнал, что появилась возможность приобрести в магазине flip.kz - купил тут же.
В предисловии автор рассказывает историю создания языков через его призму восприятия. Он пишет, что 20 лет назад языки программирования были процедурные, не было классов и ООП. И именно эти программисты, которые мыслили процедурно, и создали первые ООП-языки. Егор нисколько не умаляет их заслуг, но говорит о том, что подход к ООП с тех пор практически не изменился и программисты сейчас пишут на Java/."><meta property="og:type" content="article"><meta property="og:url" content="https://maximgorbatyuk.github.io/blog/books/2020-04-01-elegant-objects-bugayenko/"><meta property="og:image" content="https://maximgorbatyuk.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:published_time" content="2020-04-01T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-01T00:00:00+00:00"><meta property="og:site_name" content="Maxim Gorbatyuk blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://maximgorbatyuk.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Мнение о книге &#34;Elegant Objects&#34; (Vol.1) Е.Бугаенко"><meta name=twitter:description content="О книге Книга &ldquo;Элегантные объекты. Java Edition&rdquo; не сильно распространена на рынке в Казахстане, где я живу. Как только узнал, что появилась возможность приобрести в магазине flip.kz - купил тут же.
В предисловии автор рассказывает историю создания языков через его призму восприятия. Он пишет, что 20 лет назад языки программирования были процедурные, не было классов и ООП. И именно эти программисты, которые мыслили процедурно, и создали первые ООП-языки. Егор нисколько не умаляет их заслуг, но говорит о том, что подход к ООП с тех пор практически не изменился и программисты сейчас пишут на Java/."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Мнение о книге \"Elegant Objects\" (Vol.1) Е.Бугаенко","name":"Мнение о книге \u0022Elegant Objects\u0022 (Vol.1) Е.Бугаенко","description":"О книге Книга \u0026amp;ldquo;Элегантные объекты. Java Edition\u0026amp;rdquo; не сильно распространена на рынке в Казахстане, где я живу. Как только узнал, что появилась возможность приобрести в …","keywords":["codestyle","advices","programming","yegor256"],"articleBody":"О книге Книга “Элегантные объекты. Java Edition” не сильно распространена на рынке в Казахстане, где я живу. Как только узнал, что появилась возможность приобрести в магазине flip.kz - купил тут же.\nВ предисловии автор рассказывает историю создания языков через его призму восприятия. Он пишет, что 20 лет назад языки программирования были процедурные, не было классов и ООП. И именно эти программисты, которые мыслили процедурно, и создали первые ООП-языки. Егор нисколько не умаляет их заслуг, но говорит о том, что подход к ООП с тех пор практически не изменился и программисты сейчас пишут на Java/.NET/Ruby так же, как писали процедурные программисты на первых ООП-языках.\nЕгор размышлял об ООП много и пришел к выводу, что нужно начать мыслить иначе, чтобы писать более правильный ООП. А тому, что значит фраза “правильный ООП”, и посвящена книга. Труд полон противоречивых тезисов, но об этом автор прямо и пишет:\n Честно говоря, я не думаю, что прав во всем, о чем говорю. Я сам многие годы был процедурным программистом.\n Мне нравится, что Егор добавил к каждой главе комментарии других программистов, и чаще всего эти комментарии содержали противоположное мнение. Так читатель может увидеть, что думают другие “читатели”, не заходя на соответствующие блог-посты и не читая все ветки обсуждений. Ну а если у читателя возникнет такое желание, то Егор заботливо оставил ссылки на эти обсуждения. Автор ведет свой блог и даже посвятил своей книге отдельный сайт, где перечислены основные тезисы со ссылками на блог-посты с пояснениями.\nЯ не согласен со всеми принципами, к которым призывает Егор, однако большинство действительно интересны и улучшают сопровождаемость и читаемость кода. В этой статье я составлю больше конспект по книге, чтобы периодически возвращаться к ним в будущем.\nНет именам классов, оканчивающимся на -er Класс в ООП - это представитель какого-то объекта из реального мира. Основной тезис Егора в том, что в реальном мире нет Хэлперов, Врапперов, Ридеров, Хэндлеров и Контроллеров. Исключения - исторические слова наподобие User или Computer, образованные от слов use и compute соответственно.\nКласс можно назвать двумя способами: правильно и неправильно. Неправильно – это когда мы смотрим, что делает класс, а нужно смотреть, чем класс является.\n Объект - это представитель инкапсулированных в нем данных.\n Если мы называем класс именем с -er, то это говорит нам и другим программистам, что класс - набор процедур для манипулирования данными, а не сам объект. Статья Егора расскажет о принципе более подробно.\nОдин главный конструктор Конструктор класса - точка его создания. И создать объект класса можно с разным набором данным, а значит и конструкторов в нем должно быть больше чем один. Егор даже считает, что нормально, когда конструкторов в классе больше, чем его публичных методов. Автор считает, что только один конструктор должен инстанцировать себя, все же остальные конструкторы - вызывать первичный с передачей нужных параметров. Инстанцировать объект во вторичных конструкторах плохо из-за того, что это приводит к дублированию кода.\nЕсли язык, на котором вы пишете, не позволяет перегружать методы и конструкторы, то Егор, в первую очередь, советует перейти на другие языки. Если же это невозможно, то он советует принимать в конструкторе словарь “ключ-значение” и парсить его, заполняя нужные поля.\nВ конструкторах нет места коду Автор имеет в виду вызов других методов. Конструктор предназначен лишь для компоновки объектов. Есть несколько причин такого требования, в том числе филосовская и техническая. С технической точки, во-первых, зрения конструктор должен быть легковесным, чтобы не загружать память в рантайме. Во вторых, мы не вызывает операции преобразования до тех пор, пока они нам не понадобятся действительно.\nПреобразования и операции необходимо делать в публичных методах, которые вызываются по мере необходимости. Если нам понадобится закэшировать результаты, то мы можем вполне создать декоратор. Более того, Егор настоятельно и рекомендует именно так и делать вместо создания приватных полей и проверки на их заполненность.\nПринцип также находит отклик и в философском подходе к ООП: ООП – это декларативное программирование, а не императивное, но об этом позднее. У Егора есть статья на эту тему.\nИнкапсулируйте как можно меньше Чем меньше кода, тем легче его поддерживать и сопровождать. Егор рекомендует инкапсулировать не более четырех объектов. Цифра взята из ниоткуда, как признается Егор, он просто вывел ее “по опыту”. Набор инкапсулированных объектов называется состоянием (идентичностью) объекта. Это значит, что класс с одинаковыми значениями в трех его внутренних объектах должны считаться одинаковыми при операциях проверки на идентичность.\nИдентичность - это как набор координат, который идентифицирует объект. И чем больше координат мы имеем, тем тяжелее поддерживать такой код. Поэтому и руководствоваться нужно правилом “меньше - лучше”.\nИнкапсулируйте хоть что-нибудь Класс не может не иметь состояния и быть лишь набором методов. Тогда он ничем не отличается от простой коллекции “полезных” утилитарных методов, что приводит нас к процедурному программированию.\nВсегда используйте интерфейсы Использование интерфейсов необходимо для того, чтобы разорвать связь между классами. Егор не первый, кто об этом пишет. Чтобы повысить сопровождаемость, мы должны максимально расцепить (decoupling) объекты. Это дает нам возможность легче модифицировать объекты и подменять их при необходимости.\nКласс в системе живет потому, что нужен кому-то. То есть, он используется в других классах. Именно поэтому ему необходим контракт в виде интерфейса, чтобы была возможность создать и конкурентов этому классу. Пример - юниттестирование и классы-заглушки.\nТщательно выбирайте имена методов Егор рекомендует использовать два вида имен методов: методы-строители называть именами существительными, а методы-манипуляторы - глаголами.\nМетод-строитель - это такой метод, который возвращает какой-то созданный класс. Строитель никогда не должен возвращать void, это противоречит его природе. В имени метода мы также не должны указывать и способ создания объекта, используя слова fetchObject, createObject или getObject.\nЕгор приводит аналогию с кофейней. Когда мы приходим в кофейню, мы не говорим “Сварите мне кофе”, мы лишь говорим “Я бы хотел чашку кофе”. Во втором случае кофейня сама решает, как мне предоставить зака: сварить кофе, использовать быстрорастворимый или разогреть недопитый кофе предыдущего клиента (прим.ред: шутка про недопитый кофе - моя). Это и есть декларативный подход - класс, у которого мы вызываем метод, сам решает, как его создать и как его построить.\nМетоды-манипуляторы должны именоваться глаголами для того, чтобы показать, что они что-то делают и преобразовывают. Манипуляторы ничего не возвращают. Клиенты такого класса лишь просят его сделать что-либо, а класс уже сам решает, выполнить просьбу или нет. В аналогию Егор приводит пример с музыкой в кофейне. Нам, к примеру, не нравится громкость музыки в заведении. Если мы попросим убавить звук фразой “Убавьте, пожалуйста, звук, а как убавите, скажите ее громкость”. Такая просьба звучит неуважительно, мы уже вынесли решение об изменении громкости вместо того, кто на самом деле должен это делать. Именно поэтому и методы-манипуляторы возвращают лишь void.\nИсключение из правила - методы, возвращающие boolean. Например, success(). Можно было бы назвать этот метод checkSuccess(), но тогда все подобные методы содержали бы префикс check, что ухудшило бы читаемость.\nНе используйте публичные константы Какие-то данные в публичном доступе - это процедурный стиль. Их использование - это путь к увеличению связанности классов. Причем связь будет даже противоречить логике, ведь через константу можно связать классы из разных доменных областей приложения.\nКонстанта сама о себе ничего не знает. Ее используют в своих целях другие классы. Егор считает, что это неприемлемо. Альтернативой может быть класс-утилита, которая преобразует другие данные каким-то образом, пусть даже и при участии этой же константы, но только в приватной области видимости. Тогда и дублирования кода/данных не будет, и класс-утилиту можно будет протестировать.\nЧитатели могут возразить, что на каждый такой пример использования константы нужно будет создавать класс, что приведет к библиотекам из тысяч классов. Егор же считает, что это только лушче. Чем богаче наш разговорный язык на словарный запас, тем лучше мы выражаем свои мысли и тем яснее мы понятны остальным. Почему же этот же принцип нельзя применить и в языке программировании, где отдельный класс - это отдельно взятое слово.\nДелайте классы неизменяемыми Здесь Егор имеет в виду иммутабельность свойств класса. Иначе говоря, методы класса не должны менять его инкапсулированные объекты. Это противоречит идентифицируемости этих объектов. Ели нам необходимо преобразовать инкапсулированные данные, то мы должны из метода возвращать новый инстанс класса с уже измененными этими данными. В пользу использования иммутабельных объектов Егор приводит следующие эффекты:\n Атомарность отказов. Объекты инстанцируются либо полностью, либо происходит отказ операции. Отсутствие временного сцепления. Если нам нужно сформировать класс последовательным вызовом его сеттеров (про сеттеры отдельный пункт есть), то неверный порядок вызовов может привести к проблемам в рантайме. Отсутствие побочных эффектов. Человечкский фактор может привести к ошибкам в коде. Именно сокращение влияния человеческого фактора и является путем к повышению качества кода. Отсутвие NULL-ссылок. О NULL будет написан отдельный пункт, но пока что можно сказать, что если одно из наших приватных полей не инициализировано сразу, значит в остальном коде от нас потребуется проверять его на NULL постоянно. Потокобезопасность. Если наш класс используется в мультипоточном исполнении, то так может произойти, что в одном потоке класс еще полностью не был инстанцирован, а в другом от него уже ожидается некий результат. В итоге - неконсистентные операции. Объекты становятся меньше и проще. Чем проще объект, тем легче его поддерживать.  Комментаторы в блоге указывают Егору, что если инстанцировать каждый раз новые объекты, то куча (heap) может быстро заполниться ненужными объектами, и перформанс системы просядет. Егор же в ответ говорит, что сейчас железо стоит гораздо дешевле, чем время программистов, поэтому чем меньше времени программист тратит на чтение и написание кода, тем дешевле становится проект.\nБолее подробно в статье Егора.\nПишите тесты, а не документацию Важна не сама документация, а любая дополнительная информация о том, как написанный вами класс нужно использовать. Теоретически, читатель вашего кода даже и знать не должен, как формируется MD5 строки и как работает регулярное выражение, инкапсулированное в ваш класс. Но зато читатель легко поймет из написанного юниттеста, какие данные нужно подать классу на вход, чтобы получить ожидаемый результат.\nЕгор советует писать код так, чтоы его понимали не программисты со стажем, а новички, которые не знакомы со многими вещами в языке программирования, но умеющие читать текст по английски. Представьте, что читатель гораздо глупее вас, и пишите код так, чтобы он его понял.\n не хвастайтесь своими способностями - пишите простой, легко читаемый код.\n Плохие программисты пишут плохой код, а хорошие - простой. Комментаторы могут возразить, что модно задокументировать код, однако Егор считает, что один юниттест стоит страниц документации, которая вполне может быть устаревшей. Юниттест показывает, какие данные нужно подать на вход, какие ошибки в рантайме будут вызваны, какое поведение ожидается от класса.\nИспользуйте fake-объекты вместо mock-объектов Моки вынуждают авторов кода относиться к классам как к прозрачным ящикам. Более того, мокинг классов превращает предположения в факты. Например, мы передает в класс Кэша класс Биржи для конвертации валюты. Но вместо того, чтобы использовать оригинальный класс Биржи, мы создаем мок и передаем его как зависимость. В моке мы настраиваем возвращаемый результат рейта конвертации на нужный и ассертим результат работы класса Кэш. Что это значит? Что мы сделали предположение, что Кэш будет использовать метод rate() класса Биржа, хотя об этом мы можем строить лишь предположения. Получается, что если мы изменим внутренний код класса Кэш, то мок об этом ничего не узнает, и юниттесты посыпятся.\nПолучается, что мы заранее должны знать, как реализована логика класса Кэш, какие методы своих зависимостей он вызывает и на основе этой информации строить мок этих зависимостей. Философия юниттеста же заключается в том, чтобы относиться к тестируемому классу как к черному ящику и доверить ему самому решать, какие метоы он вызывает, а какие - нет.\nПримечание редактора. Не согласен с этим пунктом. Мне кажется, что создание фейк-объектов в коде самой библиотеки приведет к большим проблемам, чем даст профита. С одной стороны, мы действительно имеем возможность сразу актуализировать фейк-класс, если меняем логику проекта. Но с другой стороны, открывается возможность использовать случайно или намеренно фейковые классы в основном домене приложения, что приведет к багам в системе.\nДелайте интерфейсы краткими, используйте smart-классы Smart-класс - это вложенный класс в интерфейс, который расширяет возможности этого интерфейса. Иначе говоря, какие-то утилитарные методы, которые могут использоваться другими классами. Разделение кода на интерфейс и смарт-класс позволяет сокращать размер интерфейса и не принуждает реализовывать его имплементаторам все методы смарт-класса, которые могли бы быть частью самого интерфейса.\nПримечание редактора. Тоже спорный принцип. Ощущение, что это и есть те самвые утилитарные статические классы, против которых Егор выступает в других главах этой книги. По сути, мы просто перенесли методы-утилиты со статического класса в сам интерфейс, но не упразднили их. Либо я не понял концепции.\nПредоставляйте менее пяти публичных методов Чем меньше кода, тем легче его сопровождать. Этот принцип перекликается с принципом о четырех приватных полях. Цифра “пять” тоже взята из головы, по словам автора. Но по сути Егор прав: чем меньше публичных методов в классе, тем легче понять его предназначение.\nНе используйте статические методы Статические методы - это наследие процедурного стиля программирования. Вызов статических методов очень похож на вызов команд Ассемблера, что противоречит ООП-подходу. Программирование может быть императивным и декларативным.\nИмперативное программирование - это когда мы вызываем статический метод с параметрами в процессе исполнения программы и сохраняем в переменной ее результат “тут же”. Как в процедурном языке C до изобретения ООП. Декларативный же стиль предполагает, что мы вместо вызова операций объявляем (декларируем), что в некоторая переменная - это результат выполнения других операций, который будет вычислен позже. Реализация такого подхода достигается за счет классов и их компоновки. Затем, когда нам понадобится результат операции, мы вызываем публичный метод у созданной декларативно переменной и используем его.\nВ главе также Егор предлагает идти дальше и использовать компонуемые декораторы. Об этом он говорил еще на докладе “Utility-классы нас убивают”. Также более подробно - в статье Егора.\nПримечание редактора. Это очень сильно напоминает функциональный подход, где объявляется цепочка вызовов методов с некоторыми параметрами, но сами методы не вызываются до последнего. Также это напоминает и LinqToSQL из .NET, где мы можем навесить кучу экстеншенов на IQueryable, и только по вызову метода ToArrayAsync() мы получим искомую выборку. Иначе говоря, отложенное ленивое исполнение.\nПодход, как мне кажется, верный, но тяжело его применять. Чтобы код проекта не обрастал статическими методами, все участники команды должны следовать этому правилу.\nНе допускайте аргументов со значением NULL Отношение Егора к NULL весьма однозначно, судя по книге - их просто не должно существовать. Мысль заключается в том, что когда мы задаем значение какой-то переменной NULL, то мы заведомо начинаем не доверять своему же коду и сами решаем проверкой на NULL, нужно ли нам “общаться” с этой переменной. Иначе говоря, не спрашиваем у самого объекта, есть ли у него все нужные нам данные, а просто игнориуем его, если “ему и сказать нечего”.\nПроверки на NULL утяжеляют код, делают его менее поддерживаемым.\nПримечание редактора. Противоречивый тезис. С одной стороны, проверки на NULL действительно утяжеляют чтение кода, но эта проблема в .NET решается методом-экстеншеном (привет утилитарным методам). С другой стороны, а как можно передать “пустой” объект строки? Вводить некоторую прослойку типа Nullable? В общем, применение этого принципа повлечет утяжеление кода для неподготовленных разработчиков, нужно будет объяснять концепцию остальным сначала.\nНе используйте геттеры и сеттеры Использование гетерой и сеттеров - плохо по двум основным причинам:\n Раскрывают детали класса, делая инкапсуляцию бессмысленной. Превращают объекты в некие структуры данных наподобие DTO-классов.  Смысл инкапсуляции в том, чтобы скрыть логику работы класса, доверить ему самому решать, что нужно делать и как. Используя геттеры и сеттеры же мы обнажаем его структуру и уже сами имеем возможность манипулировать данными. Уже самим именем метода getObject() мы указываем методу, что он должен сделать. Сеттеры же нарушают описанный выше принцип иммутабельности всех объектов, давая возможность извне манипулировать внутренними данными объекта.\nНе используйте оператор new вне вторичных конструкторов Внедрение зависимостей - полезная штука, позволяющая разделить классы и уменьшить их связанность. Почему нельзя использовать new вне вторичных констрикторов? Потому что это сразу показывает плохую архитектуру класса.\nЕсли какой-то метод внезапно создает инстанс другого класса для выполнения своей логики, то это автоматически связывает оба этих класса самой жесткой связью. Мы уже не сможем подменить фейком этот класс-зависимость, не сможем протестировать разное поведение, если следовать правилу “относиться к классу как к черному ящику”.\nВторичные конструкторы нужны в классе для того, чтобы помочь инстанцировать его при недостаточности данных извне. Именно поэтому и дозволяется использовать в них оператор new, чтобы скомпоновать нужный объект.\nПримечание редактора. На удивление очень ценный принцип, о котором не сразу задумываешься при проектировании классов. Действительно, лучше предпочитать инъекцию зависимостей, показывая контракт класса всем его клиентам.\nИзбегайте интроспекции и приведения типов Интроспекция - это “рефлексия”. Приведение типов и проверка на тип вредны для кода, потому что ухудшают понимание кода. Действительно, зачем нам принимать в качестве зависимости базовый класс/интерфейс, чтобы затем проверть его на соответствие более конкретного типа и вызвать у этого самого конкретного типа его методы.\n Рефлексия - хороший инструмент для плохих программистов\n Приведение типов нарушает ООП путем дискриминации объектов по типу. Мы взаимодействуем с некоторым объектом по-разномув зависимости от его типа. Это довольно странная логика. По идее, если дочерний тип общего ведет себя иначе (раз требуется проверка на тип и приведение), то это проблема проектирования того самого дочернего типа, а не нашего класса.\nЕгор приводит в пример интересную аналогию. Приведение типов - это как будто мы зовем сантехника починить кран, но затем мы обращаемся к нему “Я полагаю, что вы еще и компьютерщик, так что почините мне принтер”. А если сантехник - никакой не компьютерщик, то у нас будет баг в системе.\nПриведение типов и интроспекция - это выражение наших ожиданий относительно объекта без документирования этих самых ожиданий. Такие непрозрачные отношения в коде серьезно снижают сопровождаемость кода.\nПримечание редактора. Еще один ценный принцип. Пока читал главу, задумался действительно, а зачем нам нужно приводить типы в коде, чтобы вызывать другие методы, а не те, которые мы “просим” по контракту в конструкторе. Получается, что применение этого принципа позволит выявить проблемы проектирования системы.\nНикогда не возвращайте NULL Принцип перекликается с тезисом о NULL в качестве аргументов. Возврат NULL принуждает клиентов нашего метода перепроверять результат нашей работы, что снижает уровень доверия к коду и классам.\nВозврат NULL в качестве результата - это в некотором роде подход “Безопасного отказа”. Противоположный подход - это “быстрый отказ” (fail fast). Безопасный отказ - это максимальные попытки “сгладить углы” и не выбрасывать исключения, а стараться обрабатывать их как можно безопаснее. Следование этому подходу может аукнуться долгоживущими багами в системе.\nПодход быстрого отказа же наоборот предостерегает систему от ошибок на самых ранних этапах попадания данных в нее. Если нам не хватает каких-то данных, то мы бросаем ошибку. Пусть клиент нашего кода сам разбирается, что он не смог передать. Мы не пытаемся исправить ошибку клиента, мы учим клиента не допускать своих ошибок.\nПримечание редактора. У меня все тот же аргумент против этого тезиса - а что делать с примитивами типа строки? Альтернативы нет, и Егор тоже не дает ее.\nБросайте только проверяемые исключения Проверяемые исключения - это те исключения в Java, которые задекларированы в его сигнатуре. Принцип хорош, принуждает программистов следовать контракту. В главе Егор дает следующие рекомендации:\n Не ловить исключения без необходимости. Пусть на более высоком уровне решают, что делать с ними. Стройте цепочки исключений. Если ловим исключение на нижних этапах, то выбрасываем новое исключение с понятным текстом ошибки и отловленным исключением в качестве InnerException Восстанавливайтесь единожды. Отлов и обработка исключений должна быть только один раз и на самом высоком уровне.  Общее мнение Мне книга в целом понравилась. Написана и переведена хорошо. Егор дает практические советы и очень подробные пояснения, почему он считает так, а не иначе. Автор показывает альтернативное мнение, взгляд на которое побуждает пересмотреть читателя свой подход к ООП и проектированию в целом.\nМне также нравится, что автор приводит и противоположное мнение комментаторов к его блог-постам по теме главы. Это показывает, что Егор открыт к дискуссиям, даже если его оппоненты не всегда (полит)корректно выражают свои мысли. Конечно, эти лишь выжимка, которая может быть выгодна автору, однако в книге приведены ссылки на конкретные обсуждения, так что любой читатель может пройти по ним и ознакомиться с оригинальными комментариями.\nНу и в довершение моей статьи-обзора-конспекта пара забавных (на мой взгляд) цитат Егора, которые он использовал в дискуссиях.\n Я думаю, что программирование - это образ жизни, религия, искусство, но никак не процесс создания инструмента. Вы проводите 1% жизни на свиданиях, а 80% - за компьютером. Почему мы должны встречаться с красивыми мужчинами/женщинами, но при этом не беспокоимся о красоте собственного кода?\n  Bruno S.: Это все придирки ради славы и денег. Делайте качественные приложения и называйте методы как угодно.\nЕгор Б.: Да, будь хорошим мальчиком, слушай маму - и все будет хорошо. Для детей это подойдет, но в серьезной разработке ПО нужны правила, принципы, дисциплина. ООП дает нам дисциплину, если мы ее правильно понимаем.\n ","wordCount":"3299","inLanguage":"en","datePublished":"2020-04-01T00:00:00Z","dateModified":"2020-04-01T00:00:00Z","author":{"@type":"Person","name":"Maxim"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://maximgorbatyuk.github.io/blog/books/2020-04-01-elegant-objects-bugayenko/"},"publisher":{"@type":"Organization","name":"Maxim Gorbatyuk blog","logo":{"@type":"ImageObject","url":"https://maximgorbatyuk.github.io/images/avatar.png"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://maximgorbatyuk.github.io/ accesskey=h title="Maxim's blog (Alt + H)"><img src=/images/avatar.png alt=logo aria-label=logo height=35>Maxim's blog</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://maximgorbatyuk.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://maximgorbatyuk.github.io/about/ title="About me"><span>About me</span></a></li><li><a href=https://maximgorbatyuk.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://maximgorbatyuk.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://maximgorbatyuk.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://maximgorbatyuk.gitbook.io/knowledge-base/ title=KB><span>KB</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Мнение о книге "Elegant Objects" (Vol.1) Е.Бугаенко</h1><div class=post-description></div><div class=post-meta>April 1, 2020&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Maxim</div></header><div class=post-content><h2 id=о-книге>О книге<a hidden class=anchor aria-hidden=true href=#о-книге>#</a></h2><p>Книга &ldquo;Элегантные объекты. Java Edition&rdquo; не сильно распространена на рынке в Казахстане, где я живу. Как только узнал, что появилась возможность приобрести в магазине flip.kz - купил тут же.</p><p>В предисловии автор рассказывает историю создания языков через его призму восприятия. Он пишет, что 20 лет назад языки программирования были процедурные, не было классов и ООП. И именно эти программисты, которые мыслили процедурно, и создали первые ООП-языки. Егор нисколько не умаляет их заслуг, но говорит о том, что подход к ООП с тех пор практически не изменился и программисты сейчас пишут на Java/.NET/Ruby так же, как писали процедурные программисты на первых ООП-языках.</p><p>Егор размышлял об ООП много и пришел к выводу, что нужно начать мыслить иначе, чтобы писать более правильный ООП. А тому, что значит фраза &ldquo;правильный ООП&rdquo;, и посвящена книга. Труд полон противоречивых тезисов, но об этом автор прямо и пишет:</p><blockquote><p>Честно говоря, я не думаю, что прав во всем, о чем говорю. Я сам многие годы был процедурным программистом.</p></blockquote><p>Мне нравится, что Егор добавил к каждой главе комментарии других программистов, и чаще всего эти комментарии содержали противоположное мнение. Так читатель может увидеть, что думают другие &ldquo;читатели&rdquo;, не заходя на соответствующие блог-посты и не читая все ветки обсуждений. Ну а если у читателя возникнет такое желание, то Егор заботливо оставил ссылки на эти обсуждения. Автор ведет свой <a href=https://www.yegor256.com>блог</a> и даже посвятил своей книге <a href=https://www.elegantobjects.org>отдельный сайт</a>, где перечислены основные тезисы со ссылками на блог-посты с пояснениями.</p><p>Я не согласен со всеми принципами, к которым призывает Егор, однако большинство действительно интересны и улучшают сопровождаемость и читаемость кода. В этой статье я составлю больше конспект по книге, чтобы периодически возвращаться к ним в будущем.</p><h2 id=нет-именам-классов-оканчивающимся-на--er>Нет именам классов, оканчивающимся на -er<a hidden class=anchor aria-hidden=true href=#нет-именам-классов-оканчивающимся-на--er>#</a></h2><p>Класс в ООП - это представитель какого-то объекта из реального мира. Основной тезис Егора в том, что в реальном мире нет Хэлперов, Врапперов, Ридеров, Хэндлеров и Контроллеров. Исключения - исторические слова наподобие User или Computer, образованные от слов use и compute соответственно.</p><p>Класс можно назвать двумя способами: правильно и неправильно. Неправильно &ndash; это когда мы смотрим, что <em>делает</em> класс, а нужно смотреть, чем класс <em>является</em>.</p><blockquote><p>Объект - это представитель инкапсулированных в нем данных.</p></blockquote><p>Если мы называем класс именем с -er, то это говорит нам и другим программистам, что класс - набор процедур для манипулирования данными, а не сам объект. <a href=https://www.yegor256.com/2015/03/09/objects-end-with-er.html>Статья</a> Егора расскажет о принципе более подробно.</p><h2 id=один-главный-конструктор>Один главный конструктор<a hidden class=anchor aria-hidden=true href=#один-главный-конструктор>#</a></h2><p>Конструктор класса - точка его создания. И создать объект класса можно с разным набором данным, а значит и конструкторов в нем должно быть больше чем один. Егор даже считает, что нормально, когда конструкторов в классе больше, чем его публичных методов. Автор считает, что только один конструктор должен инстанцировать себя, все же остальные конструкторы - вызывать первичный с передачей нужных параметров. Инстанцировать объект во вторичных конструкторах плохо из-за того, что это приводит к дублированию кода.</p><p>Если язык, на котором вы пишете, не позволяет перегружать методы и конструкторы, то Егор, в первую очередь, советует перейти на другие языки. Если же это невозможно, то он советует принимать в конструкторе словарь &ldquo;ключ-значение&rdquo; и парсить его, заполняя нужные поля.</p><h2 id=в-конструкторах-нет-места-коду>В конструкторах нет места коду<a hidden class=anchor aria-hidden=true href=#в-конструкторах-нет-места-коду>#</a></h2><p>Автор имеет в виду вызов других методов. Конструктор предназначен лишь для компоновки объектов. Есть несколько причин такого требования, в том числе филосовская и техническая. С технической точки, во-первых, зрения конструктор должен быть легковесным, чтобы не загружать память в рантайме. Во вторых, мы не вызывает операции преобразования до тех пор, пока они нам не понадобятся действительно.</p><p>Преобразования и операции необходимо делать в публичных методах, которые вызываются по мере необходимости. Если нам понадобится закэшировать результаты, то мы можем вполне создать декоратор. Более того, Егор настоятельно и рекомендует именно так и делать вместо создания приватных полей и проверки на их заполненность.</p><p>Принцип также находит отклик и в философском подходе к ООП: ООП &ndash; это декларативное программирование, а не императивное, но об этом позднее. У Егора есть <a href=https://www.yegor256.com/2015/05/07/ctors-must-be-code-free.html>статья</a> на эту тему.</p><h2 id=инкапсулируйте-как-можно-меньше>Инкапсулируйте как можно меньше<a hidden class=anchor aria-hidden=true href=#инкапсулируйте-как-можно-меньше>#</a></h2><p>Чем меньше кода, тем легче его поддерживать и сопровождать. Егор рекомендует инкапсулировать не более четырех объектов. Цифра взята из ниоткуда, как признается Егор, он просто вывел ее &ldquo;по опыту&rdquo;. Набор инкапсулированных объектов называется состоянием (идентичностью) объекта. Это значит, что класс с одинаковыми значениями в трех его внутренних объектах должны считаться одинаковыми при операциях проверки на идентичность.</p><p>Идентичность - это как набор координат, который идентифицирует объект. И чем больше координат мы имеем, тем тяжелее поддерживать такой код. Поэтому и руководствоваться нужно правилом &ldquo;меньше - лучше&rdquo;.</p><h2 id=инкапсулируйте-хоть-что-нибудь>Инкапсулируйте хоть что-нибудь<a hidden class=anchor aria-hidden=true href=#инкапсулируйте-хоть-что-нибудь>#</a></h2><p>Класс не может не иметь состояния и быть лишь набором методов. Тогда он ничем не отличается от простой коллекции &ldquo;полезных&rdquo; утилитарных методов, что приводит нас к процедурному программированию.</p><h2 id=всегда-используйте-интерфейсы>Всегда используйте интерфейсы<a hidden class=anchor aria-hidden=true href=#всегда-используйте-интерфейсы>#</a></h2><p>Использование интерфейсов необходимо для того, чтобы разорвать связь между классами. Егор не первый, кто об этом пишет. Чтобы повысить сопровождаемость, мы должны максимально расцепить (<em>decoupling</em>) объекты. Это дает нам возможность легче модифицировать объекты и подменять их при необходимости.</p><p>Класс в системе живет потому, что нужен кому-то. То есть, он используется в других классах. Именно поэтому ему необходим контракт в виде интерфейса, чтобы была возможность создать и конкурентов этому классу. Пример - юниттестирование и классы-заглушки.</p><h2 id=тщательно-выбирайте-имена-методов>Тщательно выбирайте имена методов<a hidden class=anchor aria-hidden=true href=#тщательно-выбирайте-имена-методов>#</a></h2><p>Егор рекомендует использовать два вида имен методов: методы-строители называть <em>именами существительными</em>, а методы-манипуляторы - <em>глаголами</em>.</p><p>Метод-строитель - это такой метод, который возвращает какой-то созданный класс. Строитель никогда не должен возвращать void, это противоречит его природе. В имени метода мы также не должны указывать и способ создания объекта, используя слова <em>fetchObject</em>, <em>createObject</em> или <em>getObject</em>.</p><p>Егор приводит аналогию с кофейней. Когда мы приходим в кофейню, мы не говорим &ldquo;Сварите мне кофе&rdquo;, мы лишь говорим &ldquo;Я бы хотел чашку кофе&rdquo;. Во втором случае кофейня сама решает, как мне предоставить зака: сварить кофе, использовать быстрорастворимый или разогреть недопитый кофе предыдущего клиента (<em>прим.ред: шутка про недопитый кофе - моя</em>). Это и есть декларативный подход - класс, у которого мы вызываем метод, сам решает, как его создать и как его построить.</p><p>Методы-манипуляторы должны именоваться глаголами для того, чтобы показать, что они что-то делают и преобразовывают. Манипуляторы ничего не возвращают. Клиенты такого класса лишь просят его сделать что-либо, а класс уже сам решает, выполнить просьбу или нет. В аналогию Егор приводит пример с музыкой в кофейне. Нам, к примеру, не нравится громкость музыки в заведении. Если мы попросим убавить звук фразой &ldquo;Убавьте, пожалуйста, звук, а как убавите, скажите ее громкость&rdquo;. Такая просьба звучит неуважительно, мы уже вынесли решение об изменении громкости вместо того, кто на самом деле должен это делать. Именно поэтому и методы-манипуляторы возвращают лишь void.</p><p>Исключение из правила - методы, возвращающие boolean. Например, <code>success()</code>. Можно было бы назвать этот метод <code>checkSuccess()</code>, но тогда все подобные методы содержали бы префикс <em>check</em>, что ухудшило бы читаемость.</p><h2 id=не-используйте-публичные-константы>Не используйте публичные константы<a hidden class=anchor aria-hidden=true href=#не-используйте-публичные-константы>#</a></h2><p>Какие-то данные в публичном доступе - это процедурный стиль. Их использование - это путь к увеличению связанности классов. Причем связь будет даже противоречить логике, ведь через константу можно связать классы из разных доменных областей приложения.</p><p>Константа сама о себе ничего не знает. Ее используют в своих целях другие классы. Егор считает, что это неприемлемо. Альтернативой может быть класс-утилита, которая преобразует другие данные каким-то образом, пусть даже и при участии этой же константы, но только в приватной области видимости. Тогда и дублирования кода/данных не будет, и класс-утилиту можно будет протестировать.</p><p>Читатели могут возразить, что на каждый такой пример использования константы нужно будет создавать класс, что приведет к библиотекам из тысяч классов. Егор же считает, что это только лушче. Чем богаче наш разговорный язык на словарный запас, тем лучше мы выражаем свои мысли и тем яснее мы понятны остальным. Почему же этот же принцип нельзя применить и в языке программировании, где отдельный класс - это отдельно взятое слово.</p><h2 id=делайте-классы-неизменяемыми>Делайте классы неизменяемыми<a hidden class=anchor aria-hidden=true href=#делайте-классы-неизменяемыми>#</a></h2><p>Здесь Егор имеет в виду иммутабельность свойств класса. Иначе говоря, методы класса не должны менять его инкапсулированные объекты. Это противоречит идентифицируемости этих объектов. Ели нам необходимо преобразовать инкапсулированные данные, то мы должны из метода возвращать новый инстанс класса с уже измененными этими данными. В пользу использования иммутабельных объектов Егор приводит следующие эффекты:</p><ul><li>Атомарность отказов. Объекты инстанцируются либо полностью, либо происходит отказ операции.</li><li>Отсутствие временного сцепления. Если нам нужно сформировать класс последовательным вызовом его сеттеров (про сеттеры отдельный пункт есть), то неверный порядок вызовов может привести к проблемам в рантайме.</li><li>Отсутствие побочных эффектов. Человечкский фактор может привести к ошибкам в коде. Именно сокращение влияния человеческого фактора и является путем к повышению качества кода.</li><li>Отсутвие NULL-ссылок. О NULL будет написан отдельный пункт, но пока что можно сказать, что если одно из наших приватных полей не инициализировано сразу, значит в остальном коде от нас потребуется проверять его на NULL постоянно.</li><li>Потокобезопасность. Если наш класс используется в мультипоточном исполнении, то так может произойти, что в одном потоке класс еще полностью не был инстанцирован, а в другом от него уже ожидается некий результат. В итоге - неконсистентные операции.</li><li>Объекты становятся меньше и проще. Чем проще объект, тем легче его поддерживать.</li></ul><p>Комментаторы в блоге указывают Егору, что если инстанцировать каждый раз новые объекты, то куча (heap) может быстро заполниться ненужными объектами, и перформанс системы просядет. Егор же в ответ говорит, что сейчас железо стоит гораздо дешевле, чем время программистов, поэтому чем меньше времени программист тратит на чтение и написание кода, тем дешевле становится проект.</p><p>Более подробно в <a href=http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html>статье</a> Егора.</p><h2 id=пишите-тесты-а-не-документацию>Пишите тесты, а не документацию<a hidden class=anchor aria-hidden=true href=#пишите-тесты-а-не-документацию>#</a></h2><p>Важна не сама документация, а любая дополнительная информация о том, как написанный вами класс нужно использовать. Теоретически, читатель вашего кода даже и знать не должен, как формируется MD5 строки и как работает регулярное выражение, инкапсулированное в ваш класс. Но зато читатель легко поймет из написанного юниттеста, какие данные нужно подать классу на вход, чтобы получить ожидаемый результат.</p><p>Егор советует писать код так, чтоы его понимали не программисты со стажем, а новички, которые не знакомы со многими вещами в языке программирования, но умеющие читать текст по английски. Представьте, что читатель гораздо глупее вас, и пишите код так, чтобы он его понял.</p><blockquote><p>не хвастайтесь своими способностями - пишите простой, легко читаемый код.</p></blockquote><p>Плохие программисты пишут плохой код, а хорошие - простой. Комментаторы могут возразить, что модно задокументировать код, однако Егор считает, что один юниттест стоит страниц документации, которая вполне может быть устаревшей. Юниттест показывает, какие данные нужно подать на вход, какие ошибки в рантайме будут вызваны, какое поведение ожидается от класса.</p><h2 id=используйте-fake-объекты-вместо-mock-объектов>Используйте fake-объекты вместо mock-объектов<a hidden class=anchor aria-hidden=true href=#используйте-fake-объекты-вместо-mock-объектов>#</a></h2><p>Моки вынуждают авторов кода относиться к классам как к прозрачным ящикам. Более того, мокинг классов превращает предположения в факты. Например, мы передает в класс Кэша класс Биржи для конвертации валюты. Но вместо того, чтобы использовать оригинальный класс Биржи, мы создаем мок и передаем его как зависимость. В моке мы настраиваем возвращаемый результат рейта конвертации на нужный и ассертим результат работы класса Кэш. Что это значит? Что мы сделали предположение, что Кэш будет использовать метод <code>rate()</code> класса Биржа, хотя об этом мы можем строить лишь предположения. Получается, что если мы изменим внутренний код класса Кэш, то мок об этом ничего не узнает, и юниттесты посыпятся.</p><p>Получается, что мы заранее должны знать, как реализована логика класса Кэш, какие методы своих зависимостей он вызывает и на основе этой информации строить мок этих зависимостей. Философия юниттеста же заключается в том, чтобы относиться к тестируемому классу как к черному ящику и доверить ему самому решать, какие метоы он вызывает, а какие - нет.</p><p><em>Примечание редактора. Не согласен с этим пунктом. Мне кажется, что создание фейк-объектов в коде самой библиотеки приведет к большим проблемам, чем даст профита. С одной стороны, мы действительно имеем возможность сразу актуализировать фейк-класс, если меняем логику проекта. Но с другой стороны, открывается возможность использовать случайно или намеренно фейковые классы в основном домене приложения, что приведет к багам в системе.</em></p><h2 id=делайте-интерфейсы-краткими-используйте-smart-классы>Делайте интерфейсы краткими, используйте smart-классы<a hidden class=anchor aria-hidden=true href=#делайте-интерфейсы-краткими-используйте-smart-классы>#</a></h2><p>Smart-класс - это вложенный класс в интерфейс, который расширяет возможности этого интерфейса. Иначе говоря, какие-то утилитарные методы, которые могут использоваться другими классами. Разделение кода на интерфейс и смарт-класс позволяет сокращать размер интерфейса и не принуждает реализовывать его имплементаторам все методы смарт-класса, которые могли бы быть частью самого интерфейса.</p><p><em>Примечание редактора. Тоже спорный принцип. Ощущение, что это и есть те самвые утилитарные статические классы, против которых Егор выступает в других главах этой книги. По сути, мы просто перенесли методы-утилиты со статического класса в сам интерфейс, но не упразднили их. Либо я не понял концепции.</em></p><h2 id=предоставляйте-менее-пяти-публичных-методов>Предоставляйте менее пяти публичных методов<a hidden class=anchor aria-hidden=true href=#предоставляйте-менее-пяти-публичных-методов>#</a></h2><p>Чем меньше кода, тем легче его сопровождать. Этот принцип перекликается с принципом о четырех приватных полях. Цифра &ldquo;пять&rdquo; тоже взята из головы, по словам автора. Но по сути Егор прав: чем меньше публичных методов в классе, тем легче понять его предназначение.</p><h2 id=не-используйте-статические-методы>Не используйте статические методы<a hidden class=anchor aria-hidden=true href=#не-используйте-статические-методы>#</a></h2><p>Статические методы - это наследие процедурного стиля программирования. Вызов статических методов очень похож на вызов команд Ассемблера, что противоречит ООП-подходу. Программирование может быть императивным и декларативным.</p><p>Императивное программирование - это когда мы вызываем статический метод с параметрами в процессе исполнения программы и сохраняем в переменной ее результат &ldquo;тут же&rdquo;. Как в процедурном языке <em>C</em> до изобретения ООП. Декларативный же стиль предполагает, что мы вместо вызова операций <em>объявляем</em> (декларируем), что в некоторая переменная - это результат выполнения других операций, который будет вычислен позже. Реализация такого подхода достигается за счет классов и их компоновки. Затем, когда нам понадобится результат операции, мы вызываем публичный метод у созданной декларативно переменной и используем его.</p><p>В главе также Егор предлагает идти дальше и использовать компонуемые декораторы. Об этом он говорил еще на докладе &ldquo;<a href=http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html>Utility-классы нас убивают</a>&rdquo;. Также более подробно - в <a href=http://www.yegor256.com/2017/02/07/private-method-is-new-class.html>статье</a> Егора.</p><p><em>Примечание редактора. Это очень сильно напоминает функциональный подход, где объявляется цепочка вызовов методов с некоторыми параметрами, но сами методы не вызываются до последнего. Также это напоминает и <code>LinqToSQL</code> из .NET, где мы можем навесить кучу экстеншенов на <code>IQueryable</code>, и только по вызову метода <code>ToArrayAsync()</code> мы получим искомую выборку. Иначе говоря, отложенное ленивое исполнение.</em></p><p><em>Подход, как мне кажется, верный, но тяжело его применять. Чтобы код проекта не обрастал статическими методами, все участники команды должны следовать этому правилу.</em></p><h2 id=не-допускайте-аргументов-со-значением-null>Не допускайте аргументов со значением NULL<a hidden class=anchor aria-hidden=true href=#не-допускайте-аргументов-со-значением-null>#</a></h2><p>Отношение Егора к NULL весьма однозначно, судя по книге - их просто не должно существовать. Мысль заключается в том, что когда мы задаем значение какой-то переменной NULL, то мы заведомо начинаем не доверять своему же коду и сами решаем проверкой на NULL, нужно ли нам &ldquo;общаться&rdquo; с этой переменной. Иначе говоря, не спрашиваем у самого объекта, есть ли у него все нужные нам данные, а просто игнориуем его, если &ldquo;ему и сказать нечего&rdquo;.</p><p>Проверки на NULL утяжеляют код, делают его менее поддерживаемым.</p><p><em>Примечание редактора. Противоречивый тезис. С одной стороны, проверки на NULL действительно утяжеляют чтение кода, но эта проблема в .NET решается методом-экстеншеном (привет утилитарным методам). С другой стороны, а как можно передать &ldquo;пустой&rdquo; объект строки? Вводить некоторую прослойку типа <code>Nullable&lt;T></code>? В общем, применение этого принципа повлечет утяжеление кода для неподготовленных разработчиков, нужно будет объяснять концепцию остальным сначала.</em></p><h2 id=не-используйте-геттеры-и-сеттеры>Не используйте геттеры и сеттеры<a hidden class=anchor aria-hidden=true href=#не-используйте-геттеры-и-сеттеры>#</a></h2><p>Использование гетерой и сеттеров - плохо по двум основным причинам:</p><ul><li>Раскрывают детали класса, делая инкапсуляцию бессмысленной.</li><li>Превращают объекты в некие структуры данных наподобие DTO-классов.</li></ul><p>Смысл инкапсуляции в том, чтобы скрыть логику работы класса, доверить ему самому решать, что нужно делать и как. Используя геттеры и сеттеры же мы обнажаем его структуру и уже сами имеем возможность манипулировать данными. Уже самим именем метода <code>getObject()</code> мы указываем методу, что он должен сделать. Сеттеры же нарушают описанный выше принцип иммутабельности всех объектов, давая возможность извне манипулировать внутренними данными объекта.</p><h2 id=не-используйте-оператор-new-вне-вторичных-конструкторов>Не используйте оператор new вне вторичных конструкторов<a hidden class=anchor aria-hidden=true href=#не-используйте-оператор-new-вне-вторичных-конструкторов>#</a></h2><p>Внедрение зависимостей - полезная штука, позволяющая разделить классы и уменьшить их связанность. Почему нельзя использовать new вне вторичных констрикторов? Потому что это сразу показывает плохую архитектуру класса.</p><p>Если какой-то метод внезапно создает инстанс другого класса для выполнения своей логики, то это автоматически связывает оба этих класса самой жесткой связью. Мы уже не сможем подменить фейком этот класс-зависимость, не сможем протестировать разное поведение, если следовать правилу &ldquo;относиться к классу как к черному ящику&rdquo;.</p><p>Вторичные конструкторы нужны в классе для того, чтобы помочь инстанцировать его при недостаточности данных извне. Именно поэтому и дозволяется использовать в них оператор new, чтобы скомпоновать нужный объект.</p><p><em>Примечание редактора. На удивление очень ценный принцип, о котором не сразу задумываешься при проектировании классов. Действительно, лучше предпочитать инъекцию зависимостей, показывая контракт класса всем его клиентам.</em></p><h2 id=избегайте-интроспекции-и-приведения-типов>Избегайте интроспекции и приведения типов<a hidden class=anchor aria-hidden=true href=#избегайте-интроспекции-и-приведения-типов>#</a></h2><p>Интроспекция - это &ldquo;рефлексия&rdquo;. Приведение типов и проверка на тип вредны для кода, потому что ухудшают понимание кода. Действительно, зачем нам принимать в качестве зависимости базовый класс/интерфейс, чтобы затем проверть его на соответствие более конкретного типа и вызвать у этого самого конкретного типа его методы.</p><blockquote><p>Рефлексия - хороший инструмент для плохих программистов</p></blockquote><p>Приведение типов нарушает ООП путем дискриминации объектов по типу. Мы взаимодействуем с некоторым объектом по-разномув зависимости от его типа. Это довольно странная логика. По идее, если дочерний тип общего ведет себя иначе (раз требуется проверка на тип и приведение), то это проблема проектирования того самого дочернего типа, а не нашего класса.</p><p>Егор приводит в пример интересную аналогию. Приведение типов - это как будто мы зовем сантехника починить кран, но затем мы обращаемся к нему &ldquo;Я полагаю, что вы еще и компьютерщик, так что почините мне принтер&rdquo;. А если сантехник - никакой не компьютерщик, то у нас будет баг в системе.</p><p>Приведение типов и интроспекция - это выражение наших ожиданий относительно объекта без документирования этих самых ожиданий. Такие непрозрачные отношения в коде серьезно снижают сопровождаемость кода.</p><p><em>Примечание редактора. Еще один ценный принцип. Пока читал главу, задумался действительно, а зачем нам нужно приводить типы в коде, чтобы вызывать другие методы, а не те, которые мы &ldquo;просим&rdquo; по контракту в конструкторе. Получается, что применение этого принципа позволит выявить проблемы проектирования системы.</em></p><h2 id=никогда-не-возвращайте-null>Никогда не возвращайте NULL<a hidden class=anchor aria-hidden=true href=#никогда-не-возвращайте-null>#</a></h2><p>Принцип перекликается с тезисом о NULL в качестве аргументов. Возврат NULL принуждает клиентов нашего метода перепроверять результат нашей работы, что снижает уровень доверия к коду и классам.</p><p>Возврат NULL в качестве результата - это в некотором роде подход &ldquo;Безопасного отказа&rdquo;. Противоположный подход - это &ldquo;быстрый отказ&rdquo; (fail fast). Безопасный отказ - это максимальные попытки &ldquo;сгладить углы&rdquo; и не выбрасывать исключения, а стараться обрабатывать их как можно безопаснее. Следование этому подходу может аукнуться долгоживущими багами в системе.</p><p>Подход быстрого отказа же наоборот предостерегает систему от ошибок на самых ранних этапах попадания данных в нее. Если нам не хватает каких-то данных, то мы бросаем ошибку. Пусть клиент нашего кода сам разбирается, что он не смог передать. Мы не пытаемся исправить ошибку клиента, мы учим клиента не допускать своих ошибок.</p><p><em>Примечание редактора. У меня все тот же аргумент против этого тезиса - а что делать с примитивами типа строки? Альтернативы нет, и Егор тоже не дает ее.</em></p><h2 id=бросайте-только-проверяемые-исключения>Бросайте только проверяемые исключения<a hidden class=anchor aria-hidden=true href=#бросайте-только-проверяемые-исключения>#</a></h2><p>Проверяемые исключения - это те исключения в Java, которые задекларированы в его сигнатуре. Принцип хорош, принуждает программистов следовать контракту. В главе Егор дает следующие рекомендации:</p><ul><li>Не ловить исключения без необходимости. Пусть на более высоком уровне решают, что делать с ними.</li><li>Стройте цепочки исключений. Если ловим исключение на нижних этапах, то выбрасываем новое исключение с понятным текстом ошибки и отловленным исключением в качестве <code>InnerException</code></li><li>Восстанавливайтесь единожды. Отлов и обработка исключений должна быть только один раз и на самом высоком уровне.</li></ul><h1 id=общее-мнение>Общее мнение<a hidden class=anchor aria-hidden=true href=#общее-мнение>#</a></h1><p>Мне книга в целом понравилась. Написана и переведена хорошо. Егор дает практические советы и очень подробные пояснения, почему он считает так, а не иначе. Автор показывает альтернативное мнение, взгляд на которое побуждает пересмотреть читателя свой подход к ООП и проектированию в целом.</p><p>Мне также нравится, что автор приводит и противоположное мнение комментаторов к его блог-постам по теме главы. Это показывает, что Егор открыт к дискуссиям, даже если его оппоненты не всегда (полит)корректно выражают свои мысли. Конечно, эти лишь выжимка, которая может быть выгодна автору, однако в книге приведены ссылки на конкретные обсуждения, так что любой читатель может пройти по ним и ознакомиться с оригинальными комментариями.</p><p>Ну и в довершение моей статьи-обзора-конспекта пара забавных (на мой взгляд) цитат Егора, которые он использовал в дискуссиях.</p><blockquote><p>Я думаю, что программирование - это образ жизни, религия, искусство, но никак не процесс создания инструмента. Вы проводите 1% жизни на свиданиях, а 80% - за компьютером. Почему мы должны встречаться с красивыми мужчинами/женщинами, но при этом не беспокоимся о красоте собственного кода?</p></blockquote><blockquote><p>Bruno S.: Это все придирки ради славы и денег. Делайте качественные приложения и называйте методы как угодно.</p><p>Егор Б.: Да, будь хорошим мальчиком, слушай маму - и все будет хорошо. Для детей это подойдет, но в серьезной разработке ПО нужны правила, принципы, дисциплина. ООП дает нам дисциплину, если мы ее правильно понимаем.</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://maximgorbatyuk.github.io/tags/codestyle/>codestyle</a></li><li><a href=https://maximgorbatyuk.github.io/tags/advices/>advices</a></li><li><a href=https://maximgorbatyuk.github.io/tags/programming/>programming</a></li><li><a href=https://maximgorbatyuk.github.io/tags/yegor256/>yegor256</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label='share Мнение о книге "Elegant Objects" (Vol.1) Е.Бугаенко on twitter' href="https://twitter.com/intent/tweet/?text=%d0%9c%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5%20%d0%be%20%d0%ba%d0%bd%d0%b8%d0%b3%d0%b5%20%22Elegant%20Objects%22%20%28Vol.1%29%20%d0%95.%d0%91%d1%83%d0%b3%d0%b0%d0%b5%d0%bd%d0%ba%d0%be&url=https%3a%2f%2fmaximgorbatyuk.github.io%2fblog%2fbooks%2f2020-04-01-elegant-objects-bugayenko%2f&hashtags=codestyle%2cadvices%2cprogramming%2cyegor256"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label='share Мнение о книге "Elegant Objects" (Vol.1) Е.Бугаенко on linkedin' href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmaximgorbatyuk.github.io%2fblog%2fbooks%2f2020-04-01-elegant-objects-bugayenko%2f&title=%d0%9c%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5%20%d0%be%20%d0%ba%d0%bd%d0%b8%d0%b3%d0%b5%20%22Elegant%20Objects%22%20%28Vol.1%29%20%d0%95.%d0%91%d1%83%d0%b3%d0%b0%d0%b5%d0%bd%d0%ba%d0%be&summary=%d0%9c%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5%20%d0%be%20%d0%ba%d0%bd%d0%b8%d0%b3%d0%b5%20%22Elegant%20Objects%22%20%28Vol.1%29%20%d0%95.%d0%91%d1%83%d0%b3%d0%b0%d0%b5%d0%bd%d0%ba%d0%be&source=https%3a%2f%2fmaximgorbatyuk.github.io%2fblog%2fbooks%2f2020-04-01-elegant-objects-bugayenko%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label='share Мнение о книге "Elegant Objects" (Vol.1) Е.Бугаенко on reddit' href="https://reddit.com/submit?url=https%3a%2f%2fmaximgorbatyuk.github.io%2fblog%2fbooks%2f2020-04-01-elegant-objects-bugayenko%2f&title=%d0%9c%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5%20%d0%be%20%d0%ba%d0%bd%d0%b8%d0%b3%d0%b5%20%22Elegant%20Objects%22%20%28Vol.1%29%20%d0%95.%d0%91%d1%83%d0%b3%d0%b0%d0%b5%d0%bd%d0%ba%d0%be"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label='share Мнение о книге "Elegant Objects" (Vol.1) Е.Бугаенко on facebook' href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmaximgorbatyuk.github.io%2fblog%2fbooks%2f2020-04-01-elegant-objects-bugayenko%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label='share Мнение о книге "Elegant Objects" (Vol.1) Е.Бугаенко on whatsapp' href="https://api.whatsapp.com/send?text=%d0%9c%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5%20%d0%be%20%d0%ba%d0%bd%d0%b8%d0%b3%d0%b5%20%22Elegant%20Objects%22%20%28Vol.1%29%20%d0%95.%d0%91%d1%83%d0%b3%d0%b0%d0%b5%d0%bd%d0%ba%d0%be%20-%20https%3a%2f%2fmaximgorbatyuk.github.io%2fblog%2fbooks%2f2020-04-01-elegant-objects-bugayenko%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label='share Мнение о книге "Elegant Objects" (Vol.1) Е.Бугаенко on telegram' href="https://telegram.me/share/url?text=%d0%9c%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5%20%d0%be%20%d0%ba%d0%bd%d0%b8%d0%b3%d0%b5%20%22Elegant%20Objects%22%20%28Vol.1%29%20%d0%95.%d0%91%d1%83%d0%b3%d0%b0%d0%b5%d0%bd%d0%ba%d0%be&url=https%3a%2f%2fmaximgorbatyuk.github.io%2fblog%2fbooks%2f2020-04-01-elegant-objects-bugayenko%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://maximgorbatyuk.github.io/>Maxim Gorbatyuk blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.replaceState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>